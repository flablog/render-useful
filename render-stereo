#!/bin/bash
#+
# This script invokes Blender to render the specified .blend file.
# It renders two images, offsetting the camera along its local X axis,
# and combines them to produce a stereo pair. Besides Blender, it also
# needs the Python-Cairo graphics library. Invoke it as follows:
#
#     render-stereo [options...] blendfile
#
# where the options are
#    --blender=blender
#          specifies the path to the Blender executable. Defaults to
#          searching for the name “blender” in your PATH.
#    --camera=camera
#          specifies the name of the camera to use. If omitted,
#          defaults to the active camera for the scene.
#    --offset=offset
#          specifies the distance in BU to offset the camera to each
#          side from its initial position to generate the image for
#          each eye; if omitted, defaults to 0.1.
#    --out=dest
#          the name to give the output PNG file. If omitted, defaults
#          to the basename of the input blend file with “ Stereo.png”
#          appended, saved in the current directory.
#    --percent=percent
#          specifies the percentage of the render size at which to
#          generate the images; if omitted, defaults to the last-saved
#          setting in the blendfile.
#    --samples=samples
#          the number of samples per pixel (Cycles renderer only).
#          If omitted, defaults to the last-saved setting in the
#          blendfile.
#    --scene=scene
#          specifies the scene to render. If omitted, defaults to
#          the active scene.
#
# The output file will contain the two eye images side-by-side,
# the image for the right eye on the left and vice versa, for
# viewing as “cross-eyed” stereo.
#
# Written by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
#-

blender=blender
camera=
scene=
samples=
stereo_offset=0.1
render_percentage=
out=
crossed=
for ((;;)); do
    if [ "${1:0:2}" != "--" ]; then
        break
    fi
    opt="${1:2:${#1}}"
    shift
    val="${opt#*=}"
    opt="${opt%%=*}"
    if [ "$opt" = "blender" ]; then
        blender="$val"
    elif [ "$opt" = "camera" ]; then
        camera="$val"
    elif [ "$opt" = "crossed" ]; then
        crossed=1
    elif [ "$opt" = "offset" ]; then
        stereo_offset="$val"
    elif [ "$opt" = "out" ]; then
        out="$val"
    elif [ "$opt" = "percent" ]; then
        render_percentage="$val"
    elif [ "$opt" = "samples" ]; then
        samples="$val"
    elif [ "$opt" = "scene" ]; then
        scene="$val"
    else
        echo "bad option $opt" 1>&2
        exit 3
    fi
done

if [ $# != 1 ]; then
    echo $'Usage:\n\t'"$0" $'<blendfile>\n' 1>&2
    exit 3
fi
blendfile="$1"

tmpdir="$(mktemp -d)"
script_pipe="$tmpdir/pipe.py"
image_pipe="$tmpdir/pipe.png"
mkfifo -m600 "$script_pipe"
mkfifo -m600 "$image_pipe"

# pass parameters to Python scripts in environment variables to avoid
# problems with special characters
export RENDER_stereo_offset="$stereo_offset"
if [ -n "$out" ]; then
    RENDER_image_name="$out"
else
    RENDER_image_name="${blendfile##*/}"
    RENDER_image_name="${RENDER_image_name%.*} Stereo.png"
fi
export RENDER_image_name
export RENDER_pipe="$image_pipe"
export RENDER_tmpdir="$tmpdir"
export RENDER_scene="$scene"
export RENDER_camera="$camera"
export RENDER_samples="$samples"
export RENDER_percentage="$render_percentage"
export RENDER_crossed="$crossed"

"$blender" -b "$blendfile" -P "$script_pipe" & # can't seem to put “&” on end of cmd containing a here-doc
cat >"$script_pipe" <<'EOD'
import sys
import os
import bpy
from mathutils import \
    Matrix, \
    Vector

image_pipename = os.getenv("RENDER_pipe")
tmpdirname = os.getenv("RENDER_tmpdir")
stereo_offset = float(os.getenv("RENDER_stereo_offset"))
render_percentage = os.getenv("RENDER_percentage", "")
if render_percentage != "" :
    render_percentage = int(render_percentage)
else :
    render_percentage = None
#end if
render_samples = os.getenv("RENDER_samples", "")
if render_samples != "" :
    render_samples = int(render_samples)
else :
    render_samples = None
#end if
scene_name = os.getenv("RENDER_scene", "")
if scene_name == "" :
    scene_name = None
#end if
camera_name = os.getenv("RENDER_camera", "")
if camera_name == "" :
    camera_name = None
#end if

if scene_name != None :
    bpy.context.screen.scene = bpy.data.scenes[scene_name]
#end if
if camera_name != None :
    bpy.context.scene.camera = bpy.data.objects[camera_name]
#end if
if (
        render_samples != None
    and
        hasattr(bpy.context.scene, "cycles")
    and
        bpy.context.scene.render.engine == "CYCLES"
    ) :
     bpy.context.scene.cycles.samples = render_samples
#end if
active_scene = bpy.context.scene
active_camera = active_scene.camera
orig_camera_matrix = active_camera.matrix_local

sys.stdout.write("active scene is “%s”, camera is “%s”\n" % (active_scene.name, active_camera.name))
if render_percentage != None :
    active_scene.render.resolution_percentage = render_percentage
#end if
sys.stdout.write("render resolution is %d%% * (%d, %d)\n" % (active_scene.render.resolution_percentage, active_scene.render.resolution_x, active_scene.render.resolution_y))

active_scene.render.filepath = image_pipename
for sign in (-1, +1) : # left eye, then right eye
    active_camera.matrix_local = orig_camera_matrix * Matrix.Translation(Vector((sign * stereo_offset, 0, 0)))
    bpy.ops.render.render(write_still = True)
#end for
EOD

python3 <(cat <<'EOD'
import sys
import os
import cairo

image_pipename = os.getenv("RENDER_pipe")
image_name = os.getenv("RENDER_image_name")
crossed = os.getenv("RENDER_crossed", "") != ""

left_eye = cairo.ImageSurface.create_from_png(image_pipename)
right_eye = cairo.ImageSurface.create_from_png(image_pipename)
if crossed :
    left_eye, right_eye = right_eye, left_eye
#end if
eye_offset = left_eye.get_width()
image_height = left_eye.get_height()
stereo = cairo.ImageSurface(cairo.FORMAT_RGB24, eye_offset * 2, image_height)
compose = cairo.Context(stereo)
compose.set_operator(cairo.OPERATOR_SOURCE)
compose.set_source_rgba(0, 0, 0, 0)
compose.paint()
compose.set_source_surface(right_eye, 0, 0)
compose.rectangle(0, 0, eye_offset, image_height)
compose.fill()
compose.set_source_surface(left_eye, eye_offset, 0)
compose.rectangle(eye_offset, 0, eye_offset, image_height)
compose.fill()
stereo.flush()
stereo.write_to_png(image_name)
sys.stdout.write("Saved %s\n" % image_name)
EOD
)

rm -rf "$tmpdir"
