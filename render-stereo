#!/bin/bash
#+
# This script invokes Blender to render the specified .blend file.  It
# renders two images at a time, offsetting the camera along its local
# X axis, and combines them to produce a stereo pair. Besides Blender,
# it also needs the Python-Cairo graphics library. Invoke it as
# follows:
#
#     render-stereo [options...] blendfile
#
# where the options are
#    --animation
#          specifies that an animation sequence is to be rendered.
#          If omitted, a single frame is rendered.
#    --blender=blender
#          specifies the path to the Blender executable. Defaults to
#          searching for the name “blender” in your PATH.
#    --camera=camera
#          specifies the name of the camera to use. If omitted,
#          defaults to the active camera for the scene.
#    --frame=framenr
#    --frames=[start,end[,step]]
#          specifies the frame number (if a single frame) or frame
#          range (if an animation) to be rendered, which can be empty
#          to default to the saved settings from the blend file.
#    --offset=offset
#          specifies the distance in BU to offset the camera to each
#          side from its initial position to generate the image for
#          each eye; if omitted, defaults to 0.1.
#    --out=dest
#          the name to give the output PNG file if rendering a single
#          frame, or the name of the directory into which to save the
#          numbered frames for an animation. Must be specified when
#          rendering an animation. If omitted, defaults to the
#          basename of the input blend file with “ Stereo.png”
#          appended, saved in the current directory.
#    --percent=percent
#          specifies the percentage of the render size at which to
#          generate the images; if omitted, defaults to the last-saved
#          setting in the blendfile.
#    --samples=samples
#          the number of samples per pixel (Cycles renderer only).
#          If omitted, defaults to the last-saved setting in the
#          blendfile.
#    --scene=scene
#          specifies the scene to render. If omitted, defaults to
#          the active scene.
#
# The output file will contain the two eye images side-by-side,
# the image for the right eye on the left and vice versa, for
# viewing as “cross-eyed” stereo.
#
# Written by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
#-

blender=blender
camera=
scene=
samples=
stereo_offset=0.1
digits=4
render_percentage=
out=
animation=
crossed=
for ((;;)); do
    if [ "${1:0:2}" != "--" ]; then
        break
    fi
    opt="${1:2:${#1}}"
    shift
    val="${opt#*=}"
    opt="${opt%%=*}"
    if [ "$opt" = "animation" ]; then
        animation=1
    elif [ "$opt" = "blender" ]; then
        blender="$val"
        if [ ! -x "$blender" ]; then
            echo "$0: no such executable “$blender”" 1>&2
            exit 3
        fi
    elif [ "$opt" = "camera" ]; then
        camera="$val"
    elif [ "$opt" = "crossed" ]; then
        crossed=1
    elif [ "$opt" = "digits" ]; then
        digits="$val"
    elif [ "$opt" = "frame" -o "$opt" = "frames" ]; then
        frame_spec="$val"
    elif [ "$opt" = "offset" ]; then
        stereo_offset="$val"
    elif [ "$opt" = "out" ]; then
        out="$val"
    elif [ "$opt" = "percent" ]; then
        render_percentage="$val"
    elif [ "$opt" = "samples" ]; then
        samples="$val"
    elif [ "$opt" = "scene" ]; then
        scene="$val"
    else
        echo "$0: bad option $opt" 1>&2
        exit 3
    fi
done

if [ $# != 1 ]; then
    echo "$0"$': Usage:\n\t'"$0" $'<blendfile>\n' 1>&2
    exit 3
fi
blendfile="$1"

tmpdir="$(mktemp -d)"
script_pipe="$tmpdir/pipe.py"
image_pipe="$tmpdir/pipe.png"
mkfifo -m600 "$script_pipe"
mkfifo -m600 "$image_pipe"

# pass parameters to Python scripts in environment variables to avoid
# problems with special characters
export RENDER_stereo_offset="$stereo_offset"
if [ $animation ]; then
    if [ -z "$out" ] || [ ! -d "$out" ]; then
        echo "$0: must specify --out directory for animation frames" 1>&2
        exit 3
    fi
    IFS=',' read -a frame_spec <<<"$frame_spec"
    export RENDER_frame_start="${frame_spec[0]}"
    export RENDER_frame_end="${frame_spec[1]}"
    export RENDER_frame_step="${frame_spec[2]}"
    echo "frames from $RENDER_frame_start to $RENDER_frame_end via $RENDER_frame_step" # debug
else
    export RENDER_frame_start="$frame_spec"
fi
export RENDER_animation="$animation"
if [ -n "$out" ]; then
    RENDER_out="$out"
else
    RENDER_out="${blendfile##*/}"
    RENDER_out="${RENDER_out%%.*} Stereo.png"
fi
export RENDER_out
export RENDER_pipe="$image_pipe"
export RENDER_tmpdir="$tmpdir"
export RENDER_scene="$scene"
export RENDER_camera="$camera"
export RENDER_samples="$samples"
export RENDER_percentage="$render_percentage"
export RENDER_crossed="$crossed"
export RENDER_digits="$digits"

"$blender" -b "$blendfile" -P "$script_pipe" &
# can't seem to put “&” on end of cmd containing a here-doc, so feed script separately via a pipe
# fixme: errors in this script seem to hang after Python displays the first line of the
# traceback.
cat >"$script_pipe" <<'EOD'
import sys
import os
import bpy
from mathutils import \
    Matrix, \
    Vector

def get_optional_env(varname, convert = None) :
    # returns the value of the specified environment variable, converted
    # by applying the convert function if specified; returns None if
    # the value of the variable was not specified or empty.
    val = os.getenv(varname, "")
    if val != "" :
        if convert != None :
            val = convert(val)
        #end if
    else :
        val = None
    #end if
    return \
        val
#end get_optional_env

image_pipename = os.getenv("RENDER_pipe")
tmpdirname = os.getenv("RENDER_tmpdir")
stereo_offset = float(os.getenv("RENDER_stereo_offset"))
render_percentage = get_optional_env("RENDER_percentage", int)
animation = os.getenv("RENDER_animation", "") != ""
frame_start = get_optional_env("RENDER_frame_start", int)
frame_end = get_optional_env("RENDER_frame_end", int)
frame_step = get_optional_env("RENDER_frame_step", int)
render_samples = get_optional_env("RENDER_samples", int)
scene_name = get_optional_env("RENDER_scene")
camera_name = get_optional_env("RENDER_camera")

if scene_name != None :
    bpy.context.screen.scene = bpy.data.scenes[scene_name]
#end if
if camera_name != None :
    bpy.context.scene.camera = bpy.data.objects[camera_name]
#end if
if (
        render_samples != None
    and
        hasattr(bpy.context.scene, "cycles")
    and
        bpy.context.scene.render.engine == "CYCLES"
) :
     bpy.context.scene.cycles.samples = render_samples
#end if
active_scene = bpy.context.scene
active_camera = active_scene.camera
orig_camera_matrix = active_camera.matrix_local

if frame_start == None :
    frame_start = (active_scene.frame_current, active_scene.frame_start)[animation]
#end if
if animation :
    if frame_end == None :
        frame_end = active_scene.frame_end
    #end if
    if frame_step == None :
        frame_step = active_scene.frame_step
    #end if
else :
    frame_end = frame_start
    frame_step = 1
#end if
frame_end += 1 # make it exclusive
if render_percentage != None :
    active_scene.render.resolution_percentage = render_percentage
#end if
frame_spec = open(image_pipename, "wt")
frame_spec.write("%d:%d:%d\n" % (frame_start, frame_end, frame_step))
frame_spec.flush()
frame_spec.close()

active_scene.render.filepath = image_pipename
for frame_nr in range(frame_start, frame_end, frame_step) :
    active_scene.frame_set(frame_nr)
    for sign in (-1, +1) : # left eye, then right eye
        active_camera.matrix_local = \
            (
                orig_camera_matrix
            *
                Matrix.Translation(Vector((sign * stereo_offset, 0, 0)))
            )
        bpy.ops.render.render(write_still = True)
    #end for
#end for
EOD

python3 <(cat <<'EOD'
import sys
import os
import cairo

image_pipename = os.getenv("RENDER_pipe")
render_out = os.getenv("RENDER_out")
animation = os.getenv("RENDER_animation", "") != ""
crossed = os.getenv("RENDER_crossed", "") != ""
digits = int(os.getenv("RENDER_digits"))

frame_start, frame_end, frame_step = \
    tuple(int(i) for i in open(image_pipename, "rt").read().rstrip().split(":"))
# note frame_end is exclusive

eye_offset = None
for frame_nr in range(frame_start, frame_end, frame_step) :
    left_eye = cairo.ImageSurface.create_from_png(image_pipename)
    right_eye = cairo.ImageSurface.create_from_png(image_pipename)
    if crossed :
        left_eye, right_eye = right_eye, left_eye
    #end if
    if eye_offset == None :
        eye_offset = left_eye.get_width()
        image_height = left_eye.get_height()
    #end if
    stereo = cairo.ImageSurface(cairo.FORMAT_RGB24, eye_offset * 2, image_height)
    compose = cairo.Context(stereo)
    compose.set_operator(cairo.OPERATOR_SOURCE)
    compose.set_source_rgba(0, 0, 0, 0)
    compose.paint()
    compose.set_source_surface(right_eye, 0, 0)
    compose.rectangle(0, 0, eye_offset, image_height)
    compose.fill()
    compose.set_source_surface(left_eye, eye_offset, 0)
    compose.rectangle(eye_offset, 0, eye_offset, image_height)
    compose.fill()
    stereo.flush()
    if animation :
        image_name = os.path.join(render_out, "%%0%dd.png" % digits % frame_nr)
    else :
        image_name = render_out
    #end if
    stereo.write_to_png(image_name)
    sys.stdout.write("Saved %s\n" % image_name)
#end for
EOD
)

rm -rf "$tmpdir"
echo # bring back prompt after “Blender quit” line
